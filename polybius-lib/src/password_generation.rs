use rand::Rng;

use crate::{
    password_bits::{PasswordBit, PasswordBits},
    password_data::PasswordData,
};
use rand::seq::SliceRandom; // Import the SliceRandom trait

pub struct GenerationSettings {
    pub length: usize,
    pub symbols: bool,
}

pub trait PasswordGeneration {
    /// Generates a password
    /// The password is generated by concatenating random numeric values in the numbers_poll and random acronyms of the strings in the text_poll with optionals symbols
    fn generate_password(&self, settings: &GenerationSettings) -> PasswordBits;
}

impl PasswordGeneration for PasswordData {
    fn generate_password(&self, settings: &GenerationSettings) -> PasswordBits {
        let mut bits: PasswordBits = Vec::new();
        let mut rng = rand::thread_rng();

        let generation_range = {
            if settings.symbols {
                0..=3
            } else {
                1..=3
            }
        };

        // Choose at randomly some numbers and some strings from the polls and convert them to PasswordBits
        for _ in 0..settings.length {
            match rng.gen_range(generation_range.to_owned()) {
                0 => {
                    bits.push(PasswordBit::symbol_bit());
                }
                1 => {
                    if let Some(number) = self.numbers_poll.choose(&mut rng) {
                        bits.push(PasswordBit::number_bit(number));
                    }
                }
                // Increase the probability of choosing a string
                _ => {
                    if let Some(text) = self.text_poll.choose(&mut rng) {
                        bits.push(PasswordBit::string_bit(text));
                    }
                }
            }
        }

        // Concatenate the bits to form the password
        bits
    }
}

#[cfg(test)]
mod tests {
    use crate::password_data::{Number, NumberType};

    use super::*;

    #[test]
    fn test_generate_password_empty() {
        let password_data = PasswordData::new(
            [Number::new(1, NumberType::RelevantNumber)].to_vec(),
            ["a".to_string()].to_vec(),
        );
        let generation_settings = GenerationSettings {
            length: 0,
            symbols: true,
        };
        let password_bits = password_data.generate_password(&generation_settings);
        assert_eq!(password_bits.len(), 0);
    }

    #[test]
    fn test_generate_password_no_symbols() {
        let password_data = PasswordData::new(
            [Number::new(1, NumberType::RelevantNumber)].to_vec(),
            ["a".to_string()].to_vec(),
        );
        let generation_settings = GenerationSettings {
            length: 50, // Increase the length to make the test more reliable
            symbols: false,
        };
        let password_bits = password_data.generate_password(&generation_settings);
        let symbols = vec![
            "!", "@", "#", "$", "%", "^", "&", "*", "(", ")", "-", "_", "+", "=",
        ];

        for bit in password_bits {
            if symbols.contains(&bit.bits.as_str()) {
                panic!("Found symbol: {}", bit.bits);
            }
        }
    }
}
